<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>DCS - 3.1 - Cubic Lagrange Interpolation (Uniform & Distance‑Based)</title>

    <!-- Math.js library, for any advanced math ops (not strictly needed here) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #d3d3d3;
            display: block;
            margin: 20px auto;
        }
        .legend, .explanation {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        .legend span {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 6px;
            vertical-align: middle;
        }
        .explanation {
            font-size: 14px;
            color: #333;
            line-height: 1.4;
            margin-top: 10px;
        }
    </style>
</head>

<body>

<h1 style="text-align:center;">Cubic Lagrange Interpolation</h1>

<canvas id="canvas1" width="800" height="600"></canvas>

<div class="legend">
    <p>
        <span style="background:#0066CC;"></span> Curve with uniform parameters  
        &nbsp;&nbsp;&nbsp;
        <span style="background:#CC6600;"></span> Curve with distance‑based parameters  
        &nbsp;&nbsp;&nbsp;
        <span style="border:2px solid #C00; width:14px; height:14px;"></span> Control polyline
    </p>
</div>

<div class="explanation">
    <strong>Implementation Overview:</strong><br>
    This interactive demo defines four draggable control points and computes two sets of parameter values:  
    (1) <em>Uniform</em> – evenly spaced in [0,1], and  
    (2) <em>Distance‑based</em> – proportional to the chord lengths between points.  
    For each parameterization, it constructs the four cubic Lagrange basis polynomials and evaluates the interpolant  
    at 100 sample values of <code>t</code> to obtain smooth curves. Finally, both curves are drawn in distinct colors  
    and update in real time as you drag any control point.
</div>

<script>
    var canvas1 = document.getElementById("canvas1"),
        ctx     = canvas1.getContext("2d"),
        points, style;

    // Initial control points
    points = [
        { x: 100, y: 250 },
        { x: 250, y: 100 },
        { x: 400, y: 400 },
        { x: 650, y: 200 }
    ];

    // Styles for the two curves and other elements
    style = {
        curveUniform:    { width: 4, color: "#0066CC" },  // blue
        curveNonUniform: { width: 4, color: "#CC6600" },  // orange
        polyline:        { width: 2, color: "#C00" },
        point:           {
            radius: 8,
            width: 2,
            color: "#900",
            fill:  "rgba(200,200,200,0.5)",
            arc1:   0,
            arc2:   2 * Math.PI
        }
    };

    function init() {
        ctx.lineCap  = "round";
        ctx.lineJoin = "round";
        canvas1.onmousedown = dragStart;
        canvas1.onmousemove = dragging;
        canvas1.onmouseup   = canvas1.onmouseout = dragEnd;
        drawCanvas();
    }

    // Uniform parameters [0, 1/3, 2/3, 1]
    function calculateUniformParams(n) {
        var params = [];
        for (var i = 0; i < n; i++) {
            params.push(i / (n - 1));
        }
        return params;
    }

    // Distance‑based parameters
    function calculateNonUniformParams(pts) {
        var params = [0], total = 0, acc = 0, d;
        for (var i = 1; i < pts.length; i++) {
            d = Math.hypot(pts[i].x - pts[i-1].x,
                           pts[i].y - pts[i-1].y);
            total += d;
        }
        for (i = 1; i < pts.length - 1; i++) {
            d = Math.hypot(pts[i].x - pts[i-1].x,
                           pts[i].y - pts[i-1].y);
            acc += d;
            params.push(acc / total);
        }
        params.push(1);
        return params;
    }

    // Lagrange basis polynomial L_i(t)
    function lagrangeBasis(i, t, params) {
        var res = 1;
        for (var j = 0; j < params.length; j++) {
            if (j !== i) {
                res *= (t - params[j]) / (params[i] - params[j]);
            }
        }
        return res;
    }

    // Evaluate P(t) = Σ L_i(t) P_i
    function evaluateLagrangePolynomial(t, pts, params) {
        var x = 0, y = 0, b;
        for (var i = 0; i < pts.length; i++) {
            b = lagrangeBasis(i, t, params);
            x += b * pts[i].x;
            y += b * pts[i].y;
        }
        return { x: x, y: y };
    }

    // Draw one Lagrange curve given its parameters
    function drawLagrangeCurve(ctx, curveStyle, pts, params) {
        ctx.lineWidth   = curveStyle.width;
        ctx.strokeStyle = curveStyle.color;
        ctx.beginPath();

        var p0 = evaluateLagrangePolynomial(0, pts, params);
        ctx.moveTo(p0.x, p0.y);

        var numSeg = 100;
        for (var i = 1; i <= numSeg; i++) {
            var t = i / numSeg,
                p = evaluateLagrangePolynomial(t, pts, params);
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }

    function drawPolyline(ctx, plStyle, pts) {
        ctx.lineWidth   = plStyle.width;
        ctx.strokeStyle = plStyle.color;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (var i = 1; i < pts.length; i++) {
            ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.stroke();
    }

    function drawVertices(ctx, ptStyle, pts) {
        for (var i = 0; i < pts.length; i++) {
            var p = pts[i];
            ctx.lineWidth   = ptStyle.width;
            ctx.strokeStyle = ptStyle.color;
            ctx.fillStyle   = ptStyle.fill;
            ctx.beginPath();
            ctx.arc(p.x, p.y, ptStyle.radius, ptStyle.arc1, ptStyle.arc2, true);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.font      = "12px Arial";
            ctx.fillText("P" + i, p.x + ptStyle.radius + 4, p.y - ptStyle.radius - 4);
        }
    }

    function drawGrid(ctx, w, h) {
        var step = 50;
        ctx.beginPath();
        for (var x = 0; x <= w; x += step) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
        }
        for (var y = 0; y <= h; y += step) {
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
        }
        ctx.lineWidth   = 1;
        ctx.strokeStyle = "#eee";
        ctx.stroke();
    }

    var drag = null, lastPos;
    function mousePos(e) {
        return {
            x: e.pageX - canvas1.offsetLeft,
            y: e.pageY - canvas1.offsetTop
        };
    }
    function dragStart(e) {
        var m = mousePos(e);
        for (var i = 0; i < points.length; i++) {
            var dx = points[i].x - m.x,
                dy = points[i].y - m.y;
            if (dx*dx + dy*dy < style.point.radius*style.point.radius) {
                drag    = i;
                lastPos = m;
                canvas1.style.cursor = "move";
                return;
            }
        }
    }
    function dragging(e) {
        if (drag !== null) {
            var m = mousePos(e);
            points[drag].x += (m.x - lastPos.x);
            points[drag].y += (m.y - lastPos.y);
            lastPos = m;
            drawCanvas();
        }
    }
    function dragEnd(e) {
        drag = null;
        canvas1.style.cursor = "default";
    }

    function drawCanvas() {
        ctx.clearRect(0, 0, canvas1.width, canvas1.height);
        drawGrid(ctx, canvas1.width, canvas1.height);
        drawPolyline(ctx, style.polyline, points);

        var uniParams    = calculateUniformParams(points.length),
            nonUniParams = calculateNonUniformParams(points);

        drawLagrangeCurve(ctx, style.curveUniform,    points, uniParams);
        drawLagrangeCurve(ctx, style.curveNonUniform, points, nonUniParams);

        drawVertices(ctx, style.point, points);
    }

    init();
</script>

</body>
</html>
