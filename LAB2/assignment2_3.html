<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Visualización de la parametrización de una hipocicloide</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .canvas-container {
      position: relative;
      width: 700px;
      height: 500px;
      margin: 0 auto;
      border: 1px solid #d3d3d3;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .controls {
      text-align: center;
      margin: 20px 0;
    }
    
    button {
      padding: 8px 15px;
      margin: 0 10px;
      border-radius: 4px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 15px 0;
    }
    
    .slider-container label {
      margin-right: 10px;
    }
    
    input[type="range"] {
      width: 300px;
    }
    
    .explanation {
      margin-top: 30px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #f9f9f9;
      line-height: 1.5;
    }
    
    .parameter-values {
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      background-color: #f0f0f0;
      padding: 8px;
      border-radius: 4px;
    }
  </style>
</head>
<body>

<h1>Visualización de la parametrización de una hipocicloide</h1>

<div class="canvas-container">
  <canvas id="backgroundCanvas" width="700" height="500"></canvas>
  <canvas id="dynamicCanvas" width="700" height="500"></canvas>
</div>

<div class="parameter-values" id="parameterValues">
  t = 0, x(t) = 3, y(t) = 0
</div>

<div class="controls">
  <div class="slider-container">
    <label for="speedSlider">Velocidad:</label>
    <input type="range" id="speedSlider" min="1" max="10" value="5">
  </div>
  
  <button id="playPauseBtn">Iniciar</button>
  <button id="resetBtn">Reiniciar</button>
</div>

<div class="explanation">
  <h3>Estrategia de Solución y Justificación</h3>
  
  <p><strong>Estrategia seguida:</strong></p>
  <p>
    Para resolver este problema de parametrización, usé el ángulo polar θ del centro del círculo pequeño C 
    como parámetro, tal como se indica en el enunciado. Mi enfoque consistió en:
  </p>
  <ol>
    <li>Calcular la posición del centro del círculo móvil en función de θ</li>
    <li>Determinar el ángulo de rotación α como función de θ</li>
    <li>Utilizar estas expresiones para obtener las coordenadas del punto P</li>
    <li>Simplificar las ecuaciones paramétricas resultantes</li>
  </ol>
  
  <p><strong>Justificación matemática:</strong></p>
  <p>
    Cuando el círculo C (radio r=1) rueda dentro del círculo fijo Cfixed (radio R=3r), el centro de C 
    se encuentra a una distancia (R-r)=2r del origen, con coordenadas:
  </p>
  <p style="margin-left: 20px; font-family: 'Courier New', monospace;">
    x₀ = (R-r)·cos(θ) = 2r·cos(θ)<br>
    y₀ = (R-r)·sin(θ) = 2r·sin(θ)
  </p>
  
  <p>
    Para que el círculo C ruede sin deslizamiento dentro de Cfixed, el ángulo de rotación α del círculo C 
    debe ser α = -(R/r)·θ = -3θ (el signo negativo indica rotación en sentido contrario).
  </p>
  
  <p>
    La posición del punto P se determina sumando al centro del círculo móvil, un vector de longitud r 
    en la dirección dada por θ+α:
  </p>
  <p style="margin-left: 20px; font-family: 'Courier New', monospace;">
    x = x₀ + r·cos(θ+α) = 2r·cos(θ) + r·cos(θ-3θ) = 2r·cos(θ) + r·cos(-2θ) = 2r·cos(θ) + r·cos(2θ)<br>
    y = y₀ + r·sin(θ+α) = 2r·sin(θ) + r·sin(θ-3θ) = 2r·sin(θ) + r·sin(-2θ) = 2r·sin(θ) - r·sin(2θ)
  </p>
  
  <p>
    Con r=1 como unidad básica, obtenemos exactamente las ecuaciones implementadas:
  </p>
  <p style="margin-left: 20px; font-family: 'Courier New', monospace;">
    x(θ) = 2cos(θ) + cos(2θ)<br>
    y(θ) = 2sin(θ) - sin(2θ)
  </p>
  
  <p>
    Estas ecuaciones corresponden a una hipocicloide de tres cúspides (deltoide), lo que verifica 
    la corrección de nuestra parametrización para el caso específico donde R = 3r.
  </p>
</div>

<script>
  // Get canvas elements
  const backgroundCanvas = document.getElementById("backgroundCanvas");
  const bgCtx = backgroundCanvas.getContext("2d");
  const dynamicCanvas = document.getElementById("dynamicCanvas");
  const dynCtx = dynamicCanvas.getContext("2d");
  
  // Translate to center
  const centerX = backgroundCanvas.width / 2;
  const centerY = backgroundCanvas.height / 2;
  bgCtx.translate(centerX, centerY);
  dynCtx.translate(centerX, centerY);
  
  // Constants
  const SCALE = 50; // Scale factor to make the curve visible
  const R = 3;      // Radius of fixed circle
  const r = 1;      // Radius of rolling circle
  
  // Animation variables
  let t = 0;
  const tStep = 0.01;
  let animationId = null;
  let isPlaying = false;
  let speed = 5;
  
  // Draw fixed elements
  function drawBackground() {
    bgCtx.clearRect(-centerX, -centerY, backgroundCanvas.width, backgroundCanvas.height);
    
    // Draw grid
    bgCtx.beginPath();
    bgCtx.strokeStyle = "lightgray";
    bgCtx.lineWidth = 0.5;
    
    // Vertical lines
    for (let x = -centerX; x <= centerX; x += 50) {
      bgCtx.moveTo(x, -centerY);
      bgCtx.lineTo(x, centerY);
    }
    
    // Horizontal lines
    for (let y = -centerY; y <= centerY; y += 50) {
      bgCtx.moveTo(-centerX, y);
      bgCtx.lineTo(centerX, y);
    }
    bgCtx.stroke();
    
    // Draw axes
    bgCtx.beginPath();
    bgCtx.strokeStyle = "black";
    bgCtx.lineWidth = 1;
    
    // x-axis
    bgCtx.moveTo(-centerX, 0);
    bgCtx.lineTo(centerX, 0);
    
    // y-axis
    bgCtx.moveTo(0, -centerY);
    bgCtx.lineTo(0, centerY);
    bgCtx.stroke();
    
    // Draw fixed circle (radius R)
    bgCtx.beginPath();
    bgCtx.strokeStyle = "blue";
    bgCtx.lineWidth = 2;
    bgCtx.arc(0, 0, R * SCALE, 0, 2 * Math.PI);
    bgCtx.stroke();
    
    // Draw coordinate labels
    bgCtx.fillStyle = "black";
    bgCtx.font = "12px Arial";
    bgCtx.fillText("(0,0)", 5, 15);
    bgCtx.fillText("x", centerX - 15, 15);
    bgCtx.fillText("y", 5, -centerY + 15);
  }
  
  // Compute hypocycloid point for parameter t
  function computePoint(t) {
    const factor = R - r; // Which is 2 in our case
    
    const x = factor * Math.cos(t) + r * Math.cos(factor * t / r);
    const y = factor * Math.sin(t) - r * Math.sin(factor * t / r);
    
    return { x, y };
  }
  
  // Draw the dynamic elements (rolling circle, trace point, traced curve)
  function drawDynamic(currentT) {
    dynCtx.clearRect(-centerX, -centerY, dynamicCanvas.width, dynamicCanvas.height);
    
    // Compute point on hypocycloid
    const point = computePoint(currentT);
    
    // Compute center of rolling circle
    const rollingCenterX = (R - r) * Math.cos(currentT);
    const rollingCenterY = (R - r) * Math.sin(currentT);
    
    // Draw the full traced curve (light red)
    dynCtx.beginPath();
    dynCtx.strokeStyle = "rgba(255, 0, 0, 0.3)";
    dynCtx.lineWidth = 2;
    
    // Start at t=0
    let startPoint = computePoint(0);
    dynCtx.moveTo(startPoint.x * SCALE, startPoint.y * SCALE);
    
    // Plot the full curve
    for (let t = 0; t <= 2 * Math.PI; t += 0.01) {
      let p = computePoint(t);
      dynCtx.lineTo(p.x * SCALE, p.y * SCALE);
    }
    dynCtx.stroke();
    
    // Draw the traced curve up to current point (bright red)
    dynCtx.beginPath();
    dynCtx.strokeStyle = "red";
    dynCtx.lineWidth = 3;
    
    // Start at t=0
    dynCtx.moveTo(startPoint.x * SCALE, startPoint.y * SCALE);
    
    // Plot the curve up to current t
    for (let t = 0; t <= currentT; t += 0.01) {
      let p = computePoint(t);
      dynCtx.lineTo(p.x * SCALE, p.y * SCALE);
    }
    dynCtx.stroke();
    
    // Draw rolling circle
    dynCtx.beginPath();
    dynCtx.strokeStyle = "green";
    dynCtx.lineWidth = 2;
    dynCtx.arc(rollingCenterX * SCALE, rollingCenterY * SCALE, r * SCALE, 0, 2 * Math.PI);
    dynCtx.stroke();
    
    // Draw center of rolling circle
    dynCtx.beginPath();
    dynCtx.fillStyle = "green";
    dynCtx.arc(rollingCenterX * SCALE, rollingCenterY * SCALE, 4, 0, 2 * Math.PI);
    dynCtx.fill();
    
    // Draw tracing point
    dynCtx.beginPath();
    dynCtx.fillStyle = "red";
    dynCtx.arc(point.x * SCALE, point.y * SCALE, 6, 0, 2 * Math.PI);
    dynCtx.fill();
    
    // Draw line connecting center to point
    dynCtx.beginPath();
    dynCtx.strokeStyle = "green";
    dynCtx.lineWidth = 1;
    dynCtx.moveTo(rollingCenterX * SCALE, rollingCenterY * SCALE);
    dynCtx.lineTo(point.x * SCALE, point.y * SCALE);
    dynCtx.stroke();
    
    // Update parameter values display
    document.getElementById("parameterValues").innerHTML = 
      `t = ${currentT.toFixed(2)}, x(t) = ${point.x.toFixed(2)}, y(t) = ${point.y.toFixed(2)}`;
  }
  
  // Animation function
  function animate() {
    // Increment t based on speed
    t += tStep * speed;
    
    // Reset after full cycle
    if (t > 2 * Math.PI) {
      t = 0;
    }
    
    // Draw the current state
    drawDynamic(t);
    
    // Continue animation if playing
    if (isPlaying) {
      animationId = requestAnimationFrame(animate);
    }
  }
  
  // Initialize controls
  const playPauseBtn = document.getElementById("playPauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const speedSlider = document.getElementById("speedSlider");
  
  playPauseBtn.addEventListener("click", function() {
    isPlaying = !isPlaying;
    
    if (isPlaying) {
      playPauseBtn.textContent = "Pausar";
      animate();
    } else {
      playPauseBtn.textContent = "Iniciar";
      cancelAnimationFrame(animationId);
    }
  });
  
  resetBtn.addEventListener("click", function() {
    t = 0;
    isPlaying = false;
    playPauseBtn.textContent = "Iniciar";
    cancelAnimationFrame(animationId);
    drawDynamic(t);
  });
  
  speedSlider.addEventListener("input", function() {
    speed = parseInt(this.value);
  });
  
  // Initial setup
  drawBackground();
  drawDynamic(t);
</script>

</body>
</html>