<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypocycloid Parametrization Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .canvas-container {
      position: relative;
      width: 700px;
      height: 500px;
      margin: 0 auto;
      border: 1px solid #d3d3d3;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .controls {
      text-align: center;
      margin: 20px 0;
    }
    
    button {
      padding: 8px 15px;
      margin: 0 10px;
      border-radius: 4px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 15px 0;
    }
    
    .slider-container label {
      margin-right: 10px;
    }
    
    input[type="range"] {
      width: 300px;
    }
    
    .explanation {
      margin-top: 30px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #f9f9f9;
      line-height: 1.5;
    }
    
    .parameter-values {
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      background-color: #f0f0f0;
      padding: 8px;
      border-radius: 4px;
    }
  </style>
</head>
<body>

<h1>Parametrization Visualization</h1>

<div class="canvas-container">
  <canvas id="backgroundCanvas" width="700" height="500"></canvas>
  <canvas id="dynamicCanvas" width="700" height="500"></canvas>
</div>

<div class="parameter-values" id="parameterValues">
  t = 0, x(t) = 3, y(t) = 0
</div>

<div class="controls">
  <div class="slider-container">
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="1" max="10" value="5">
  </div>
  
  <button id="playPauseBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>

<div class="explanation">
  <title>Solution Strategy and Mathematical Justification</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h2 {
            color: #222;
            border-bottom: 2px solid #ccc;
            padding-bottom: 5px;
        }
        ol {
            margin-left: 20px;
        }
        .equation {
            background-color: #eef;
            padding: 10px;
            border-radius: 5px;
            font-family: "Courier New", monospace;
            margin: 10px 0;
        }
    </style>
</head>
<body>

<h2>Solution Strategy and Mathematical Justification</h2>

<h3>Approach:</h3>
<p>
To solve this parametrization problem, I used the polar angle <strong>θ</strong> of the center of the smaller circle <strong>C</strong> as the parameter, as suggested in the problem statement. Specifically, I followed these steps:
</p>
<ol>
    <li><strong>Calculated</strong> the coordinates of the moving circle’s center as functions of <strong>θ</strong>.</li>
    <li><strong>Determined</strong> the rotation angle <strong>α</strong> of the small circle as a function of <strong>θ</strong>.</li>
    <li><strong>Combined</strong> these results to find the coordinates of the tracing point <strong>P</strong>.</li>
    <li><strong>Simplified</strong> the resulting parametric equations.</li>
</ol>

<h3>Mathematical Justification:</h3>
<p>
When the smaller circle <strong>C</strong> with radius <strong>r = 1</strong> rolls inside the fixed circle <strong>C<sub>fixed</sub></strong> with radius <strong>R = 3r = 3</strong>, the distance between their centers remains constant at <strong>R - r = 2</strong>. Thus, the coordinates of the smaller circle’s center become:
</p>
<div class="equation">
    x₀ = (R - r) cos(θ) = 2 cos(θ),<br>
    y₀ = (R - r) sin(θ) = 2 sin(θ)
</div>

<p>
For the smaller circle <strong>C</strong> to roll without slipping inside <strong>C<sub>fixed</sub></strong>, the rotation angle <strong>α</strong> must satisfy:
</p>
<div class="equation">
    α = -(R/r) θ = -3θ
</div>

<p>(The negative sign indicates rotation in the opposite direction to the movement around the fixed circle.)</p>

<p>
The coordinates of point <strong>P</strong> are then found by adding a vector of length <strong>r = 1</strong>, oriented by the angle <strong>θ + α</strong>, to the center coordinates of the smaller circle:
</p>
<div class="equation">
    x = x₀ + r cos(θ + α) = 2 cos(θ) + cos(θ - 3θ) = 2 cos(θ) + cos(-2θ) = 2 cos(θ) + cos(2θ)
</div>
<div class="equation">
    y = y₀ + r sin(θ + α) = 2 sin(θ) + sin(θ - 3θ) = 2 sin(θ) + sin(-2θ) = 2 sin(θ) - sin(2θ)
</div>

<p>
With <strong>r = 1</strong>, these equations become precisely the simplified parametric equations implemented in this solution:
</p>
<div class="equation">
    x(θ) = 2 cos(θ) + cos(2θ),<br>
    y(θ) = 2 sin(θ) - sin(2θ)
</div>

<p>
These results verify the correctness of my parametrization for the given conditions.
</p>

</body>
</div>

<script>
  // Get canvas elements
  const backgroundCanvas = document.getElementById("backgroundCanvas");
  const bgCtx = backgroundCanvas.getContext("2d");
  const dynamicCanvas = document.getElementById("dynamicCanvas");
  const dynCtx = dynamicCanvas.getContext("2d");
  
  // Translate to center
  const centerX = backgroundCanvas.width / 2;
  const centerY = backgroundCanvas.height / 2;
  bgCtx.translate(centerX, centerY);
  dynCtx.translate(centerX, centerY);
  
  // Constants
  const SCALE = 50; // Scale factor to make the curve visible
  const R = 3;      // Radius of fixed circle
  const r = 1;      // Radius of rolling circle
  
  // Animation variables
  let t = 0;
  const tStep = 0.01;
  let animationId = null;
  let isPlaying = false;
  let speed = 5;
  
  // Draw fixed elements
  function drawBackground() {
    bgCtx.clearRect(-centerX, -centerY, backgroundCanvas.width, backgroundCanvas.height);
    
    // Draw grid
    bgCtx.beginPath();
    bgCtx.strokeStyle = "lightgray";
    bgCtx.lineWidth = 0.5;
    
    // Vertical lines
    for (let x = -centerX; x <= centerX; x += 50) {
      bgCtx.moveTo(x, -centerY);
      bgCtx.lineTo(x, centerY);
    }
    
    // Horizontal lines
    for (let y = -centerY; y <= centerY; y += 50) {
      bgCtx.moveTo(-centerX, y);
      bgCtx.lineTo(centerX, y);
    }
    bgCtx.stroke();
    
    // Draw axes
    bgCtx.beginPath();
    bgCtx.strokeStyle = "black";
    bgCtx.lineWidth = 1;
    
    // x-axis
    bgCtx.moveTo(-centerX, 0);
    bgCtx.lineTo(centerX, 0);
    
    // y-axis
    bgCtx.moveTo(0, -centerY);
    bgCtx.lineTo(0, centerY);
    bgCtx.stroke();
    
    // Draw fixed circle (radius R)
    bgCtx.beginPath();
    bgCtx.strokeStyle = "blue";
    bgCtx.lineWidth = 2;
    bgCtx.arc(0, 0, R * SCALE, 0, 2 * Math.PI);
    bgCtx.stroke();
    
    // Draw coordinate labels
    bgCtx.fillStyle = "black";
    bgCtx.font = "12px Arial";
    bgCtx.fillText("(0,0)", 5, 15);
    bgCtx.fillText("x", centerX - 15, 15);
    bgCtx.fillText("y", 5, -centerY + 15);
  }
  
  // Compute hypocycloid point for parameter t
  function computePoint(t) {
    const factor = R - r; // Which is 2 in our case
    
    const x = factor * Math.cos(t) + r * Math.cos(factor * t / r);
    const y = factor * Math.sin(t) - r * Math.sin(factor * t / r);
    
    return { x, y };
  }
  
  // Draw the dynamic elements (rolling circle, trace point, traced curve)
  function drawDynamic(currentT) {
    dynCtx.clearRect(-centerX, -centerY, dynamicCanvas.width, dynamicCanvas.height);
    
    // Compute point on hypocycloid
    const point = computePoint(currentT);
    
    // Compute center of rolling circle
    const rollingCenterX = (R - r) * Math.cos(currentT);
    const rollingCenterY = (R - r) * Math.sin(currentT);
    
    // Draw the full traced curve (light red)
    dynCtx.beginPath();
    dynCtx.strokeStyle = "rgba(255, 0, 0, 0.3)";
    dynCtx.lineWidth = 2;
    
    // Start at t=0
    let startPoint = computePoint(0);
    dynCtx.moveTo(startPoint.x * SCALE, startPoint.y * SCALE);
    
    // Plot the full curve
    for (let t = 0; t <= 2 * Math.PI; t += 0.01) {
      let p = computePoint(t);
      dynCtx.lineTo(p.x * SCALE, p.y * SCALE);
    }
    dynCtx.stroke();
    
    // Draw the traced curve up to current point (bright red)
    dynCtx.beginPath();
    dynCtx.strokeStyle = "red";
    dynCtx.lineWidth = 3;
    
    // Start at t=0
    dynCtx.moveTo(startPoint.x * SCALE, startPoint.y * SCALE);
    
    // Plot the curve up to current t
    for (let t = 0; t <= currentT; t += 0.01) {
      let p = computePoint(t);
      dynCtx.lineTo(p.x * SCALE, p.y * SCALE);
    }
    dynCtx.stroke();
    
    // Draw rolling circle
    dynCtx.beginPath();
    dynCtx.strokeStyle = "green";
    dynCtx.lineWidth = 2;
    dynCtx.arc(rollingCenterX * SCALE, rollingCenterY * SCALE, r * SCALE, 0, 2 * Math.PI);
    dynCtx.stroke();
    
    // Draw center of rolling circle
    dynCtx.beginPath();
    dynCtx.fillStyle = "green";
    dynCtx.arc(rollingCenterX * SCALE, rollingCenterY * SCALE, 4, 0, 2 * Math.PI);
    dynCtx.fill();
    
    // Draw tracing point
    dynCtx.beginPath();
    dynCtx.fillStyle = "red";
    dynCtx.arc(point.x * SCALE, point.y * SCALE, 6, 0, 2 * Math.PI);
    dynCtx.fill();
    
    // Draw line connecting center to point
    dynCtx.beginPath();
    dynCtx.strokeStyle = "green";
    dynCtx.lineWidth = 1;
    dynCtx.moveTo(rollingCenterX * SCALE, rollingCenterY * SCALE);
    dynCtx.lineTo(point.x * SCALE, point.y * SCALE);
    dynCtx.stroke();
    
    // Update parameter values display
    document.getElementById("parameterValues").innerHTML = 
      `t = ${currentT.toFixed(2)}, x(t) = ${point.x.toFixed(2)}, y(t) = ${point.y.toFixed(2)}`;
  }
  
  // Animation function
  function animate() {
    // Increment t based on speed
    t += tStep * speed;
    
    // Reset after full cycle
    if (t > 2 * Math.PI) {
      t = 0;
    }
    
    // Draw the current state
    drawDynamic(t);
    
    // Continue animation if playing
    if (isPlaying) {
      animationId = requestAnimationFrame(animate);
    }
  }
  
  // Initialize controls
  const playPauseBtn = document.getElementById("playPauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const speedSlider = document.getElementById("speedSlider");
  
  playPauseBtn.addEventListener("click", function() {
    isPlaying = !isPlaying;
    
    if (isPlaying) {
      playPauseBtn.textContent = "Pause";
      animate();
    } else {
      playPauseBtn.textContent = "Start";
      cancelAnimationFrame(animationId);
    }
  });
  
  resetBtn.addEventListener("click", function() {
    t = 0;
    isPlaying = false;
    playPauseBtn.textContent = "Start";
    cancelAnimationFrame(animationId);
    drawDynamic(t);
  });
  
  speedSlider.addEventListener("input", function() {
    speed = parseInt(this.value);
  });
  
  // Initial setup
  drawBackground();
  drawDynamic(t);
</script>

</body>
</html>